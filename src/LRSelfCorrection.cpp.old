#include <fstream>
#include <iostream>
#include <ctime>
#include <cmath>
#include <chrono>
#include "LRSelfCorrection.h"
#include "localAlignment.h"
#include "kMersProcessing.h"
#include "DBG.h"
#include "../BMEAN/bmean.h"
#include "../BMEAN/utils.h"
#include "../BMEAN/Complete-Striped-Smith-Waterman-Library/src/ssw_cpp.h"

std::mutex outMtx;

bool isUpperCase(char c) {
	return 'A' <= c and c <= 'Z';
}

int nbCorBases(std::string correctedRead) {
	int n = 0;
	for (unsigned i = 0; i < correctedRead.length(); i++) {
		if ('A' <= correctedRead[i] && correctedRead[i] <= 'Z') {
			n++;
		}
	}

	return n;
}

bool dropRead(std::string correctedRead) {
	return (float) nbCorBases(correctedRead) / correctedRead.length() < 0.75;
}


void toUpperCase(std::string& s, int beg, int end) {
	std::locale loc;
	for (int i = beg; i < end; i++) {
		s[i] = std::toupper(s[i], loc);
	}
}

void toLowerCase(std::string& s, int beg, int end) {
	std::locale loc;
	for (int i = beg; i < end; i++) {
		s[i] = std::tolower(s[i], loc);
	}
}

std::vector<std::string> trimRead(std::string correctedRead, unsigned merSize) {
	return {correctedRead};
	std::vector<std::string> res;
	unsigned beg, end, n;
	beg = 0;
	end = 0;
	unsigned i = 0;
	n = 0;

	while (i < correctedRead.length()) {
		while (i < correctedRead.length() and !isUpperCase(correctedRead[i])) {
			i++;
		}
		beg = i;
		n = 0;

		while (i < correctedRead.length() and n < merSize) {
			if (!isUpperCase(correctedRead[i])) {
				n++;
			} else {
				n = 0;
			}
			i++;
		}

		end = i - n - 1;
		if (end >= beg) {
			std::string split = correctedRead.substr(beg, end - beg + 1);
			// std::cerr << "split : " << split << std::endl;
			if (!dropRead(split)) {
				res.push_back(split);
			}
		}
	}

	return res;
}

std::string weightConsensus(std::string& consensus, std::vector<std::string>& pile, std::unordered_map<std::string, unsigned>& merCounts, unsigned merSize, unsigned windowSize, unsigned solidThresh) {
	std::vector<std::string> splits;
	std::string curSplit;

	std::string header = "";
	std::string sequence = "";
	std::string curFct;

	unsigned i = 0;
	while (i < consensus.length() - merSize + 1) {
		curFct = consensus.substr(i, merSize);
		toUpperCase(curFct, 0, merSize);
		if (merCounts[curFct] >= solidThresh) {
			toUpperCase(consensus, i, i + merSize - 1);
		} else {
			toLowerCase(consensus, i, i + merSize - 1);
		}
		i++;
	}

	return consensus;
}

std::string computeConsensuses(std::string& readId, std::vector<std::string> & piles, std::pair<unsigned, unsigned>& pilesPos, std::string& readsDir, unsigned& minSupport, unsigned& merSize, unsigned& commonKMers, unsigned& solidThresh, unsigned& windowSize) {
	auto start_antoine = std::chrono::high_resolution_clock::now();
	std::string res;

	// for (std::string s : piles) {
	// 	std::cerr << s << std::endl;
	// }
	// return piles[0];
	//6,10 curBest
	std::vector<std::vector<std::string>> result = MSABMAAC(piles, 7, std::min(10, (int) piles.size()));
	auto end_antoine = std::chrono::high_resolution_clock::now();
	// std::cerr << "antoine took " << std::chrono::duration_cast<std::chrono::milliseconds>(end_antoine - start_antoine).count() << " ms\n";

	auto c_start = std::chrono::high_resolution_clock::now();
	std::string consSeq = result[0][0];
	// std::cerr << "I GOT : " << consSeq << std::endl;
	std::transform(consSeq.begin(), consSeq.end(), consSeq.begin(), ::toupper);
	// Align the computed consensus to the template, to retrieve the (raw, corrected) pairs of subsequences
	std::string corTpl = consSeq;
	std::string rawTpl = piles[0];
	if (!consSeq.empty()) {
		// std::cerr << ">consSeq" << std::endl << consSeq << std::endl;

		// Declares a default Aligner
		StripedSmithWaterman::Aligner aligner;
		// Declares a default filter
		StripedSmithWaterman::Filter filter;
		// Declares an alignment that stores the result
		StripedSmithWaterman::Alignment alignment;
		// Declares the masklen (useful only for suboptimal alignments)
		int32_t maskLen = 15;

		// Aligns the query to the ref
		// aligner.Align(piles[0].c_str(), consSeq.c_str(), consSeq.size(), filter, &alignment, maskLen);

		// int qBeg, qEnd, rBeg, rEnd;
		// qBeg = alignment.query_begin;
		// qEnd = alignment.query_end;
		// rBeg = alignment.ref_begin;
		// rEnd = alignment.ref_end;
		
		// rawTpl = piles[0].substr(qBeg, qEnd - qBeg + 1);
		// corTpl = consSeq.substr(rBeg, rEnd - rBeg + 1);



		// Polish the consensus
		std::vector<std::pair<std::string, std::string>> corList;
		auto merCounts = getKMersCounts(piles, merSize, solidThresh);
		if (corTpl.length() >= merSize) {
			corTpl = weightConsensus(corTpl, piles, merCounts, merSize, windowSize, solidThresh);
		}
		auto c_start = std::chrono::high_resolution_clock::now();
		corList = polishCorrection(corTpl, merCounts, merSize, solidThresh);
		auto c_end = std::chrono::high_resolution_clock::now();
		std::cerr << "polishing took " << std::chrono::duration_cast<std::chrono::milliseconds>(c_end - c_start).count() << " ms\n";
		for (std::pair<std::string, std::string> p : corList) {
			std::string r = p.first;
			// std::cerr << ">replacing" << std::endl << r << std::endl;
			std::string c = p.second;
			// std::cerr << ">with" << std::endl << c << std::endl;
			int b, l;
			b = corTpl.find(r);
			l = r.length();
			if ((int) b != -1) {
				corTpl.replace(b, l, c);
			}
		}
		std::transform(corTpl.begin(), corTpl.end(), corTpl.begin(), ::toupper);

		// std::cerr << ">corTpl" << std::endl << corTpl << std::endl;
		// res[0] = std::make_pair(rawTpl, corTpl);
		res = corTpl;
	}
	auto c_end = std::chrono::high_resolution_clock::now();
	// std::cerr << "voting took " << std::chrono::duration_cast<std::chrono::milliseconds>(c_end - c_start).count() << " ms\n";

	return res;
}

std::string alignConsensuses(std::string rawRead, std::string sequence, std::vector<std::string>& consensuses, std::vector<std::pair<unsigned, unsigned>>& pilesPos, std::vector<std::vector<std::string>>& piles, int startPos) {
	int beg, end;
	std::string outSequence;
	outSequence = sequence;
	std::transform(outSequence.begin() + startPos, outSequence.end(), outSequence.begin() + startPos, ::tolower);

	std::cerr << "sizes : " << consensuses.size() << " ; " << pilesPos.size() << std::endl;

	std::string corWindow;
	unsigned i = 0;
	std::pair<std::string, std::string> c;
	std::string tmpSequence, consUp;
	std::pair<unsigned, unsigned> pPos;
	int curPos = 0;
	for (i = 0; i < consensuses.size(); i++) {
		// c = consensuses[i];
		consUp = consensuses[i];
		pPos = pilesPos[i];
		// Don't proceed if no consensus was produced by POA
		if (!consUp.empty()) {
			// Align the consensus to the read
			// consUp = c.second;
			// Declares a default Aligner
			StripedSmithWaterman::Aligner aligner;
			// Declares a default filter
			StripedSmithWaterman::Filter filter;
			// Declares an alignment that stores the result
			StripedSmithWaterman::Alignment alignment;
			// Declares the masklen (useful only for suboptimal alignments)
			int32_t maskLen = 15;
			// std::cerr << "pilePos : " << pPos.first << " ; " << pPos.second << std::endl;

			std::cerr << "aligning : " << consUp << std::endl;
			std::cerr << "to : " << outSequence.substr(curPos, pPos.second - pPos.first + 1 + 100) << std::endl;
			int sizeAl;
			if (curPos + pPos.second - pPos.first + 1 + 100 >= outSequence.length()) {
				sizeAl = outSequence.length() - curPos;
			} else {
				sizeAl = pPos.second - pPos.first + 1 + 100;
			}
			aligner.Align(consUp.c_str(), outSequence.c_str() + curPos, sizeAl, filter, &alignment, maskLen);

			std::cerr << "aligned" << std::endl;

			beg = alignment.ref_begin + curPos;
			end = alignment.ref_end + curPos;
			consUp = consUp.substr(alignment.query_begin, alignment.query_end - alignment.query_begin + 1);

			// aligner.Align(c.second.c_str(), outSequence.c_str(), outSequence.length(), filter, &alignment, maskLen);
			// beg = alignment.ref_begin;
			// end = alignment.ref_end;
			// consUp = consUp.substr(alignment.query_begin, alignment.query_end - alignment.query_begin + 1);
			
			outSequence.replace(beg, end - beg + 1, consUp);
			curPos = end - 50;

			// std::pair<std::pair<int, int>, std::pair<int, int>> posPair = NeedlemanWunschLocalAlignments(c.second, outSequence);
			// beg = posPair.second.first;
			// end = posPair.second.second;
			// consUp = consUp.substr(posPair.first.first, posPair.first.second - posPair.first.first + 1);


			// std::cerr << "cons size : " << consUp.length() << std::endl;
			// std::cerr << "beg : " << alignment.query_begin << std::endl;
			// std::cerr << "end : " << alignment.query_end << std::endl;

			// std::cerr << "cons size : " << consUp.length() << std::endl;
			// std::cerr << "beg : " << posPair.first.first << std::endl;
			// std::cerr << "end : " << posPair.first.second << std::endl;
			// std::cerr << "read size : " << outSequence.length() << std::endl;
			// std::cerr << "beg : " << posPair.second.first << std::endl;
			// std::cerr << "end : " << posPair.second.second << std::endl;
			
			// std::cerr << std::endl;

		} else {
			// TODO: may cause bugs
			beg = -1;
			end = -1;
		}
	}

	return outSequence;
}

int getNextSrc(std::string correctedRead, unsigned beg, unsigned merSize) {
	unsigned nb = 0;
	unsigned i = beg;

	while (i < correctedRead.length() and (isUpperCase(correctedRead[i]) or nb < merSize)) {
		if (isUpperCase(correctedRead[i])) {
			nb++;
		} else {
			nb = 0;
		}
		i++;
	}

	return nb >= merSize ? i - 1 : -1;
}

int getNextDst(std::string correctedRead, unsigned beg, unsigned merSize) {
	unsigned nb = 0;
	unsigned i = beg;

	while (i < correctedRead.length() and nb < merSize) {
		if (isUpperCase(correctedRead[i])) {
			nb++;
		} else {
			nb = 0;
		}
		i++;
	}

	return nb >= merSize ? i - 1 : -1;
}


// Anchors without repeated k-mers
std::vector<std::pair<std::string, std::string>> getAnchors(std::unordered_map<std::string, unsigned>& merCounts, std::string srcZone, std::string dstZone, unsigned merSize, unsigned nb) {
	std::vector<std::pair<std::string, std::string>> res;
	unsigned i;

	std::unordered_map<std::string, std::vector<unsigned>> mersPosSrc = getKMersPos(srcZone, merSize);
	std::unordered_map<std::string, std::vector<unsigned>> mersPosDst = getKMersPos(dstZone, merSize);

	// Consider all k-mers of the src zone as potential anchors
	std::vector<std::string> candidatesSrc(srcZone.size() - merSize + 1);
	for (i = 0; i < srcZone.size() - merSize + 1; i++) {
		candidatesSrc[i] = srcZone.substr(i, merSize);
	}
	// Same with the dst zone
	std::vector<std::string> candidatesDst(dstZone.size() - merSize + 1);
	for (i = 0; i < dstZone.size() - merSize + 1; i++) {
		candidatesDst[i] = dstZone.substr(i, merSize);
	}

	// Add the anchors pairs to the result vector, without allowing repeated k-mers
	for (std::string csrc : candidatesSrc) {
		if (mersPosSrc[csrc].size() == 1) {
			for (std::string cdst : candidatesDst) {
				if (mersPosDst[cdst].size() == 1) {
					res.push_back(std::make_pair(csrc, cdst));
				}
			}
		}
	}

	// Sort the anchors vector in ascending order of the number of occurrences of (src + dst)
	std::sort(res.begin(), res.end(),
		[&merCounts](std::pair<std::string, std::string>& r1, std::pair<std::string, std::string>& r2) {
			int occ1 = merCounts[r1.first] + merCounts[r1.second];
			int occ2 = merCounts[r2.first] + merCounts[r2.second];
			return occ1 > occ2;
		}
	);

	std::vector<std::pair<std::string, std::string>> finalRes;
	for (i = 0; i < nb and i < res.size(); i++) {
		finalRes.push_back(res[i]);
	}

	return finalRes;
}

std::vector<std::pair<std::string, std::string>> polishCorrection(std::string correctedRead, std::unordered_map<std::string, unsigned>& merCounts, unsigned merSize, int solidThresh) {
	std::set<std::string> visited;
	unsigned curBranches;
	unsigned dist;
	std::string curExt;
	std::string correctedRegion;
	unsigned maxSize;
	unsigned maxBranches = 50;
	std::vector<std::pair<std::string, std::string>> corList;
	// int zone = 4;
	int zone = 3;
	int srcBeg, srcEnd, dstBeg, dstEnd;
	int tmpSrcBeg = 0, tmpSrcEnd = 0, tmpDstBeg = 0, tmpDstEnd = 0;
	std::string src, dst;
	std::pair<int, int> pos;
	std::vector<std::pair<std::string, std::string>> anchors;
	unsigned anchorNb;
	std::string srcZone, dstZone;
	std::unordered_map<std::string, std::vector<unsigned>> srcPos, dstPos;

	// Skip uncorrected head of the read
	unsigned i = 0;
	while (i < correctedRead.length() and !isUpperCase(correctedRead[i])) {
		i++;
	}

	// Search for poorly supported regions bordered by solid corrected regions
	while (i < correctedRead.length()) {
		srcEnd = getNextSrc(correctedRead, i, merSize + zone);
		dstEnd = getNextDst(correctedRead, srcEnd + 1, merSize + zone);
		srcBeg = srcEnd - merSize - zone + 1;
		dstBeg = dstEnd - merSize - zone + 1;

		// Polish the poorly supported region region if 2 anchors were found
		if (srcEnd != -1 and dstEnd != -1) {
			correctedRegion = "";
			srcZone = correctedRead.substr(srcBeg, merSize + zone);
			dstZone = correctedRead.substr(dstBeg, merSize + zone);
			anchors = getAnchors(merCounts, srcZone, dstZone, merSize, 5);
			srcPos = getKMersPos(srcZone, merSize);
			dstPos = getKMersPos(dstZone, merSize);

			// Attempt to link frequent anchors
			anchorNb = 0;
			while (anchorNb < anchors.size() and correctedRegion.empty()) {
				src = anchors[anchorNb].first;
				dst = anchors[anchorNb].second;
				tmpSrcBeg = srcBeg + srcPos[src][0];
				tmpSrcEnd = tmpSrcBeg + merSize - 1;
				tmpDstBeg = dstBeg + dstPos[dst][0];
				tmpDstEnd = tmpDstBeg + merSize - 1;
				
				auto c_start = std::chrono::high_resolution_clock::now();
				if (src != dst) {
					curBranches = 0;
					dist = 0;
					curExt = src;
					correctedRegion = "";
					maxSize = 15.0 / 100.0 * 2.0 * (tmpDstBeg - tmpSrcEnd - 1) + (tmpDstBeg - tmpSrcEnd - 1) + merSize;
					link(merCounts, src, dst, merSize, visited, &curBranches, dist, curExt, correctedRegion, merSize, maxSize, maxBranches, solidThresh, merSize);
				}
				anchorNb++;
				auto c_end = std::chrono::high_resolution_clock::now();
				// std::cerr << "linking2 took " << std::chrono::duration_cast<std::chrono::milliseconds>(c_end - c_start).count() << " ms\n";
			}

			if (!correctedRegion.empty()) {
				corList.push_back(std::make_pair(correctedRead.substr(tmpSrcBeg, tmpDstEnd - tmpSrcBeg + 1), correctedRegion));
			}

			i = tmpDstBeg;
		} else {
			i = correctedRead.length();	
		}
	}

	return corList;
}

void processRead(std::vector<Alignment>& alignments, std::string readsDir, unsigned minSupport, unsigned windowSize, unsigned merSize, unsigned commonKMers, unsigned solidThresh, unsigned windowOverlap) {
	std::string readId = alignments.begin()->qName;

	// Compute alignment piles
	auto c_start = std::chrono::high_resolution_clock::now();
	std::unordered_map<std::string, std::string> sequences = getSequencesunordered_maps(alignments, readsDir);
	std::pair<std::vector<std::pair<unsigned, unsigned>>, std::vector<std::vector<std::string>>> pairPiles = getAlignmentPiles(alignments, minSupport, windowSize, windowOverlap, sequences);
	std::vector<std::vector<std::string>> piles = pairPiles.second;
	std::vector<std::pair<unsigned, unsigned>> pilesPos = pairPiles.first;
	auto c_end = std::chrono::high_resolution_clock::now();
	// std::cerr << "init took " << std::chrono::duration_cast<std::chrono::milliseconds>(c_end - c_start).count() << " ms\n";
	unsigned i = 0;

	// Compute consensuses for all the piles
	auto c_start1 = std::chrono::high_resolution_clock::now();
	std::vector<std::string> consensuses(piles.size());
	// std::vector<std::pair<std::string, std::string>> curCons;
	for (i = 0; i < piles.size(); i++) {
		std::cerr << "go compute" << std::endl;
		consensuses[i] = computeConsensuses(readId, piles[i], pilesPos[i], readsDir, minSupport, merSize, commonKMers, solidThresh, windowSize);
		std::cerr << "did compute" << std::endl;
	}
	auto c_end1 = std::chrono::high_resolution_clock::now();
	// std::cerr << "consensus took " << std::chrono::duration_cast<std::chrono::milliseconds>(c_end1 - c_start1).count() << " ms\n";

	// Align computed consensuses to the read and retrieve poorly supported regions windows positions
	c_start = std::chrono::high_resolution_clock::now();
	std::cerr << "go align" << std::endl;
	std::string correctedRead = alignConsensuses(readId, sequences[alignments[0].qName], consensuses, pilesPos, piles, 0);
	std::cerr << "did align" << std::endl;
	c_end = std::chrono::high_resolution_clock::now();
	std::cerr << "anchoring1 took " << std::chrono::duration_cast<std::chrono::milliseconds>(c_end - c_start).count() << " ms\n";

	// Drop read if it contains too many poorly supported bases
	// if (!dropRead(correctedRead)) {
	if (1) {
		// Trim the read (trims until a long sketch of corrected bases if found. Ex: aaaaCCggagtAttagGGACTTACGATCGATCGATCa => GGACTTACGATCGATCGATC)
		c_start = std::chrono::high_resolution_clock::now();
		std::vector<std::string> correctedSplits = trimRead(correctedRead, windowSize);
		unsigned nbSplit = 0;
		while (nbSplit < correctedSplits.size()) {
			outMtx.lock();
			std::cout << ">" << readId << "_" << nbSplit + 1 << std::endl << correctedSplits[nbSplit] << std::endl;
			outMtx.unlock();
			nbSplit++;
		}

		// outMtx.lock();
		// std::cout << ">" << readId << std::endl << correctedRead << std::endl;
		// outMtx.unlock();
	}

	sequences.clear();
	piles.clear();
	pilesPos.clear();
	alignments.clear();
}


void processReads(std::vector<std::vector<Alignment>>& reads, std::string readsDir, unsigned minSupport, unsigned windowSize, unsigned merSize, unsigned commonKMers, unsigned solidThresh, unsigned windowOverlap) {
	std::vector<std::pair<std::string, std::string>> consensuses;

	for (std::vector<Alignment> alignments : reads) {
		auto c_start = std::chrono::high_resolution_clock::now();
		processRead(alignments, readsDir, minSupport, windowSize, merSize, commonKMers, solidThresh, windowOverlap);
		auto c_end = std::chrono::high_resolution_clock::now();
		// std::cerr << "kMersProcessingng " << alignments[0].qName << " took " << std::chrono::duration_cast<std::chrono::milliseconds>(c_end - c_start).count() << " ms\n";
	}

	reads.clear();
}

// Multithread ok, but running with GNU parallel for now.
// Multithreading seems to consume lots of resources when processing large number of reads.
void runCorrection(std::string alignmentFile, std::string readsDir, unsigned minSupport, unsigned windowSize, unsigned merSize, unsigned commonKMers, unsigned solidThresh, unsigned windowOverlap, unsigned nbThreads) {	
	std::ifstream f(alignmentFile);
	std::vector<Alignment> curReadAlignments;
	Alignment al;
	std::string curRead, line;
	curRead = "";
	int readNumber = 0;

	// Init threads
	std::vector<std::vector<std::vector<Alignment>>> reads(nbThreads);
	for (unsigned i = 0; i < nbThreads; i++) {
		reads[i] = std::vector<std::vector<Alignment>>();
	}

	getline(f, line);
	while(line.length() > 0 or !curReadAlignments.empty()) {
		if (line.length() > 0) {
			al = Alignment(line);
		}
		if (line.length() > 0 and (curRead == "" or al.qName == curRead)) {
			curRead = al.qName;
			curReadAlignments.push_back(al);
			getline(f, line);
		} else {
			std::sort(curReadAlignments.begin(), curReadAlignments.end());
			reads[readNumber % nbThreads].push_back(curReadAlignments);	
			readNumber++;
			curReadAlignments.clear();
			curRead = "";
		}
	}

	// Launch threads
	std::vector<std::future<void>> threads(nbThreads);
	for (unsigned i = 0 ; i < nbThreads ; i++) {
		std::vector<std::vector<Alignment>> als = reads[i];
		threads[i] = async(std::launch::async, [als, readsDir, minSupport, windowSize, merSize, commonKMers, solidThresh, windowOverlap]() mutable {
			processReads(als, readsDir, minSupport, windowSize, merSize, commonKMers, solidThresh, windowOverlap);
		});
	}
	
	// Get threads results
	for (std::future<void> &t: threads) {
		t.get();
	}
}
